function varargout = align_exernal_nanosims(varargin)
% ALIGN_EXERNAL_NANOSIMS MATLAB code for align_exernal_nanosims.fig
%      ALIGN_EXERNAL_NANOSIMS, by itself, creates a new ALIGN_EXERNAL_NANOSIMS or raises the existing
%      singleton*.
%
%      H = ALIGN_EXERNAL_NANOSIMS returns the handle to a new ALIGN_EXERNAL_NANOSIMS or the handle to
%      the existing singleton*.
%
%      ALIGN_EXERNAL_NANOSIMS('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in ALIGN_EXERNAL_NANOSIMS.M with the given input arguments.
%
%      ALIGN_EXERNAL_NANOSIMS('Property','Value',...) creates a new ALIGN_EXERNAL_NANOSIMS or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before align_exernal_nanosims_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to align_exernal_nanosims_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help align_exernal_nanosims

% Last Modified by GUIDE v2.5 22-Aug-2011 08:30:42

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @align_exernal_nanosims_OpeningFcn, ...
                   'gui_OutputFcn',  @align_exernal_nanosims_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before align_exernal_nanosims is made visible.
function align_exernal_nanosims_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to align_exernal_nanosims (see VARARGIN)

set(handles.figure1,'Name','Align external and nanosims images');
if(nargin>3)
    handles.flag = varargin{1};
    handles.imagedir = varargin{2};
    handles.mag_factor = varargin{3};
    %handles.additional_settings = varargin{3};
end
handles.points_color_symbol = 'k';
handles.points_font_color = 'w';

% Choose default command line output for align_exernal_nanosims
handles.output = hObject;

global align_axes1 align_axes2
align_axes1=handles.axes1;
align_axes2=handles.axes2;

handles = update_gui_fontsize(handles);

% Update handles structure
guidata(hObject, handles);

% UIWAIT makes align_exernal_nanosims wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = align_exernal_nanosims_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% --- Executes on button press in pushbutton1.
function pushbutton1_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

function align_help_Callback(hObject, eventdata, handles)
if hObject == handles.what_to_do    
    helpdlg({
        '(1) Use the File menu to load the images that you want to align.';
        '- Supported formats for external images: TIF, BMP, PNG, or XYZ (e.g. obtained by AFM).';
        '- Supported formats for nanosims images: MAT or TIF (as generated by Look@nanoSIMS).';
        '';
        '(2) Decide how you want to perform the alignment:';
        '(a) interactively using a keyboard';
        '(b) based on 2 points (no warping)';
        '(c) based on >4 points (with warping)';
        ' - In (a) you will define the rotation, magnification and offset interactively using your keyboard.';
        ' - In (b-c) rotation, magnification and offset calculated will be calculated automatically based on pairs of points that you will define.';
        '';
        '(3) If you decide to use methods (b-c), you must first define 2 (method b) or at least 4 (method c) pairs of matching points. Do this by first defining the point in the left image and then the corresponding matching point in the right image. Repeat this until you define all pairs of points.';
        ' - If the points were previously defined and saved, you can load the list of points using the File menu.';
        ' - If you want to modify a point''s position or remove a pair of points, use the corresponding action from the Action menu.';
        '';
        '(4) Choose the appropriate alignment method from the Action menu, as described in point 2.';
        '';
        '(5) When satisfied with the alignment, choose ''Export aligned external image'' from the Action menu, define the output filename, and save the results.';
        ' - If you defined pairs of points, it is adviced to save them using the File menu. They might be useful in the future.'
        },...
        'What to do?'); 
elseif hObject == handles.how_to_add_points
    helpdlg({'1. Select Add point from the Action menu.';
        '2. First, define a point in the left image. Immediately afterwards, define the corresponding matching point in the right image.';
        '3. When defining a point, use *left* mouse click to *define its position*, or *arrows* to *move* the defined point in fine steps.';
        '4. If satisfied with the point''s position, use *right* mouse click or press *enter* to *confirm* it.';
        '5. Any time you can press Esc to *cancel* the point definition.'},...
        'How to add a point?');
elseif hObject == handles.how_to_modify_point
    helpdlg({'1. Select Modify point from the Action menu.';
        '2. *Choose a point* that you want to modify, either in the left or right image, by *clicking on it* with the *left* mouse button. *Confirm* the point selection using the *right* mouse button or by pressing *enter*.';
        '3. Use *left* mouse botton again to define the *new* point position. Here you can *use arrows* to more accurately place the point.';
        '4. *Confirm* the point''s position using the *right* mouse botton or by pressing *enter*.';
        '5. Any time you can press Esc to cancel this action.'},...
        'How to modify a point?');
elseif hObject == handles.how_to_remove_points
    helpdlg({'1. Select Remove pair of points from the Action menu.';
        '2. Use *left* mouse click to *select* a point for removal, either in the left of right image.';
        '3. Use *right* mouse click or press *enter* to *remove* it.'},...
        'How to remove a pair of points?');
end

% --------------------------------------------------------------------
function add_point_Callback(hObject, eventdata, handles)
% hObject    handle to add_point (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

disp('*** Interactive addition of a point.');
fprintf(1,'- Left-click on the image to define a point\n');
fprintf(1,'  - Use arrows to move it\n')
fprintf(1,'- Right-click or Enter to confirm the point location\n');
fprintf(1,'- Press Esc to cancel action\n');

set(gcf, 'pointer', 'cross');
[x, y, m, ax] = my_ginput(handles.figure1);
x=round(x);
y=round(y);

%[x,y,m]=ginput(1);

if ax == handles.axes1
    if isfield(handles,'extplist')
        plist = handles.extplist;
    else
        plist = [];
    end
    symb = 'x';
else
    if isfield(handles,'nanosimsplist')
        plist = handles.nanosimsplist;
    else
        plist = [];
    end
    symb = '+';
end

m=1; p=[];
while m~=3 && m~=13 && m~=27
    
    if isempty(p)
        %axes(ax);
        hold on;
        p = plot(x,y,[handles.points_color_symbol symb],'markerfacecolor',[1 1 1],'markersize',12,'linewidth',2);
    else
        set(p,'xdata',x,'ydata',y);
    end
    
    [x1, y1, m] = my_ginput(handles.figure1);
    x1=round(x1);
    y1=round(y1);
    %[x1,y1,m]=ginput(1);
    if isempty(m)
        m=3;
    end
    xl = get(ax,'xlim');
    yl = get(ax,'ylim');
    if m==28
        x = x-1;
        if x<1, x=1; end
    end
    if m==29
        x = x+1;
        if x>ceil(xl(2)), x=ceil(xl(2)); end
    end
    if m==30
        y = y-1;
        if y<1, y=1; end
    end
    if m==31
        y = y+1;       
        if y>ceil(yl(2)), y=ceil(yl(2)); end
    end
    if m==1
        x = x1; y=y1;
    end
    
end

set(gcf, 'pointer', 'arrow');

% add defined point to the plist
if m==3 || m==13
    plist = [plist; [x y]];
    n=size(plist,1);
    tt=text(x+diff(xl)/64,y,num2str(n));
    set(tt,'color', handles.points_font_color)
    fprintf(1,'Point [%d %d] added to the list.\n',x,y);
else
    fprintf(1,'No point added.\n');
end
% update handles
if ax == handles.axes1
   handles.extplist = plist;
else
   handles.nanosimsplist = plist;
end

guidata(hObject, handles);

update_points_Callback(hObject, eventdata, handles);

% if gca == handles.axes1
%     if isfield(handles,'extplist')
%         fprintf(1,'External plist:\n');
%         fprintf(1,'%d %d\n',round(handles.extplist));
%     end;
% else
%     if isfield(handles,'nanosimsplist')
%         fprintf(1,'Nanosims plist:\n');
%         fprintf(1,'%d %d\n',round(handles.nanosimsplist));
%     end;
% end;

% --------------------------------------------------------------------
function remove_point_Callback(hObject, eventdata, handles)
% hObject    handle to remove_point (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

disp('*** Interactive removal of a pair of points.');
disp(' - Left-click           = select point;');
disp(' - Right-click or Enter = remove selected point and its corresponding pair;');
disp(' - Esc                  = cancel action;');

%[x,y,m,ax]=ginputc(1,'Color','w');

set(gcf, 'pointer', 'hand');
[x, y, m, ax] = my_ginput(handles.figure1);
x=round(x);
y=round(y);
 
if(isempty(m)) % i.e. Enter was pressed
    m=1;
end

while m~=3 && m~=13 && m~=27
    
    if ax == handles.axes1
        if isfield(handles,'extplist')
            plist = handles.extplist;
        else
            plist = [];
        end
    else
        if isfield(handles,'nanosimsplist')
            plist = handles.nanosimsplist;
        else
            plist = [];
        end
    end

    if isempty(plist)
        fprintf(1,'List of points empty\n');
        ind = [];
    else
        d = (plist(:,1)-x).^2 + (plist(:,2)-y).^2;
        [m1, ind]=min(d);
        ind=ind(1);
        fprintf(1,'Points %d selected for removal\n',ind);
    end
    
    [x, y, m, ax] = my_ginput(handles.figure1);
    x=round(x);
    y=round(y);
    %[x,y,m]=ginputc(1,'Color','w');

end

set(gcf, 'pointer', 'arrow');

% remove point from the current plist
if ~isempty(ind) && (m==3 || m==13)
    plist = plist(setdiff([1:size(plist,1)],ind),:);
    fprintf(1,'Points %d removed.\n',ind);
    
    % update handles
    if ax == handles.axes1
       handles.extplist = plist;
       % remove points also from the plist in the complementary image (here
       % nanosims image)
       if ~isempty(ind) && isfield(handles,'nanosimsplist')
            plist = handles.nanosimsplist;
            plist = plist(setdiff([1:size(plist,1)],ind),:);
            handles.nanosimsplist = plist;
       end
    else
       handles.nanosimsplist = plist;
       % remove points also from the plist in the complementary image (here
       % external image)
       if ~isempty(ind) && isfield(handles,'extplist')
            plist = handles.extplist;
            plist = plist(setdiff([1:size(plist,1)],ind),:);
            handles.extplist = plist;
       end
    end

    update_points_Callback(hObject, eventdata, handles);

end

guidata(hObject, handles);

function modify_point_Callback(hObject, eventdata, handles)
% hObject    handle to remove_point (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

disp('*** Interactive modification of a point.');
disp(' - Left-click           = select point;');
disp(' - Right-click or Enter = confirm point selection;');
disp(' - Esc                  = cancel action;');

set(gcf, 'pointer', 'hand');
[x, y, m, ax] = my_ginput(handles.figure1);
x=round(x);
y=round(y);
 
if(isempty(m)) % i.e. Enter was pressed
    m=1;
end

while m~=3 && m~=13 && m~=27
    
    if ax == handles.axes1
        if isfield(handles,'extplist')
            plist = handles.extplist;
        else
            plist = [];
        end
    else
        if isfield(handles,'nanosimsplist')
            plist = handles.nanosimsplist;
        else
            plist = [];
        end
    end

    if isempty(plist)
        fprintf(1,'List of points empty\n');
        ind = [];
    else
        d = (plist(:,1)-x).^2 + (plist(:,2)-y).^2;
        [m1, ind]=min(d);
        ind=ind(1);
        fprintf(1,'Point %d selected.\n',ind);
    end
    
    [x, y, m, newax] = my_ginput(handles.figure1);
    x=round(x);
    y=round(y);
    
    if m==1, ax=newax; end

end

if m==3 || m==13
    
    set(gcf, 'pointer', 'cross');
    axes(ax);
    x = plist(ind,1);
    y = plist(ind,2);
    xorig=x;
    yorig=y;
    
    % remove the point first
    plist2 = plist(setdiff([1:size(plist,1)],ind),:);
    if ax == handles.axes1
       handles.extplist = plist2;
       symb = 'x';
    else
        handles.nanosimsplist = plist2;
        symb = '+';
    end
    
    % update the points, which will effectively delete the point from the
    % displayed image
    update_points_Callback(hObject, eventdata, handles);
    
    % draw the point again, to get a plot handle that we can modify below
    axes(ax); hold on;
    p = plot(x,y,[handles.points_color_symbol symb],'markerfacecolor',[1 1 1],'markersize',12,'linewidth',2);
            
    fprintf(1,'*** Modify point %d using mouse or arrows.\n',ind);
    fprintf(1,'  - Left-click on the image to place the point\n');
    fprintf(1,'    - Use arrows to move it\n')
    fprintf(1,'  - Right-click or Enter to confirm the point location\n');
    fprintf(1,'  - Press Esc to cancel action\n');

    m=1; 
    while m~=3 && m~=13 && m~=27
        
        set(p,'xdata',x,'ydata',y);

        [x1, y1, m] = my_ginput(handles.figure1);
        x1=round(x1);
        y1=round(y1);

        if isempty(m)
            m=3;
        end
        xl = get(ax,'xlim');
        yl = get(ax,'ylim');
        if m==28
            x = x-1;
            if x<1, x=1; end
        end
        if m==29
            x = x+1;
            if x>ceil(xl(2)), x=ceil(xl(2)); end
        end
        if m==30
            y = y-1;
            if y<1, y=1; end
        end
        if m==31
            y = y+1;       
            if y>ceil(yl(2)), y=ceil(yl(2)); end
        end
        if m==1
            x = (x1); y=(y1);
        end
        fprintf(1,'New point position: [%d %d]\n',round(x),round(y));

    end 

    % add defined point to the plist
    if m==3 || m==13
        plist(ind,1:2) = [x y];
        fprintf(1,'Point %d modified to [%d %d].\n',ind,x,y);
    else
        % use the original point position if Esc was pressed
        plist(ind,1:2) = [xorig yorig];
        fprintf(1,'Point %d unchanged.\n',ind);
    end

    % update handles
    if ax == handles.axes1
       handles.extplist = plist;
    else
       handles.nanosimsplist = plist;
    end

    % this will effectively redraw and renumber all the defined points
    % correctly
    update_points_Callback(hObject, eventdata, handles);
    guidata(hObject, handles);
    
end
set(gcf, 'pointer', 'arrow');

% --------------------------------------------------------------------
function show_alignment_Callback(hObject, eventdata, handles)
% hObject    handle to show_alignment (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

log_flag1 = get(handles.checkbox1,'value');
log_flag2 = get(handles.checkbox2,'value');

ext_vscale = str2num([get(handles.min_ext,'String'), ...
        ' ', get(handles.max_ext,'String')]);
ns_vscale = str2num([get(handles.min_ns,'String'), ...
        ' ', get(handles.max_ns,'String')]);
    
if hObject == handles.show_alignment4
    % set flags
    set(handles.show_alignment4,'Checked','on');
    set(handles.show_alignment2,'Checked','off');
    set(handles.align_interactively,'Checked','off');
    align_type = 4;
    % align based on multiple (>4) points
    v1 = round(handles.extplist');
    v2 = round(handles.nanosimsplist');    
    [ext_aligned, ext_aligned_xyscale, f_aligned] = ...
        align2images(v1,v2,handles.extimage,handles.nanosimsimage,...
            ext_vscale, ns_vscale,...
            handles.extimage_xyscale,handles.nanosimsimage_xyscale,...
            log_flag1,log_flag2,handles.points_color_symbol);        
    
elseif hObject == handles.align_interactively
    % set flags
    set(handles.show_alignment4,'Checked','off');
    set(handles.show_alignment2,'Checked','off');
    set(handles.align_interactively,'Checked','on');
    align_type = 1;
    im1 = handles.extimage;
    s1 = handles.extimage_xyscale;
    im2 = handles.nanosimsimage;
    s2 = handles.nanosimsimage_xyscale;
    if size(im1,3)>1
        im1 = rgb2gray_lans(im1);
    end
    x1 = floor(get(handles.axes1,'xlim')); x1=x1(1):x1(2);
    y1 = floor(get(handles.axes1,'ylim')); y1=y1(1):y1(2);
    x2 = floor(get(handles.axes2,'xlim')); x2=x2(1):x2(2);
    y2 = floor(get(handles.axes2,'ylim')); y2=y2(1):y2(2);
    x1 = x1(x1>0 & x1<=size(im1,2));
    y1 = y1(y1>0 & y1<=size(im1,1));
    x2 = x2(x2>0 & x2<=size(im2,2));
    y2 = y2(y2>0 & y2<=size(im2,1));
    
    im1 = double(im1(y1,x1));
    im2 = im2(y2,x2);
    if s1==size(handles.extimage,2)
        % this means that we do not know the correct scale of the external
        % image, so the scales will be in pixels
        s1 = size(im1,2);
        s2 = size(im2,2);
    end
    [ext_aligned, ext_aligned_xyscale, rgb_aligned, f_aligned] = ...
        align_interactively(im1,im2,...
        ext_vscale, ns_vscale,...
        s1,s2,log_flag1,log_flag2);

elseif hObject == handles.show_alignment2
    % set flags
    set(handles.show_alignment4,'Checked','off');
    set(handles.show_alignment2,'Checked','on');
    set(handles.align_interactively,'Checked','off');
    % align based on multiple 2 points and known scale
    align_type = 2;
    im1 = handles.extimage;
    s1 = handles.extimage_xyscale;
    im2 = handles.nanosimsimage;
    s2 = handles.nanosimsimage_xyscale;
    if size(im1,3)>1
        im1 = rgb2gray_lans(im1);
    end
    x1 = floor(get(handles.axes1,'xlim')); x1=x1(1):x1(2);
    y1 = floor(get(handles.axes1,'ylim')); y1=y1(1):y1(2);
    x2 = floor(get(handles.axes2,'xlim')); x2=x2(1):x2(2);
    y2 = floor(get(handles.axes2,'ylim')); y2=y2(1):y2(2);
    x1 = x1(x1>0 & x1<=size(im1,2));
    y1 = y1(y1>0 & y1<=size(im1,1));
    x2 = x2(x2>0 & x2<=size(im2,2));
    y2 = y2(y2>0 & y2<=size(im2,1));
    
    im1 = double(im1(y1,x1));
    im2 = im2(y2,x2);
    v1 = round(handles.extplist');
    v2 = round(handles.nanosimsplist');
    extimage_xyscale = handles.extimage_xyscale * size(im1,2)/size(handles.extimage,2);
    [ext_aligned, ext_aligned_xyscale, rgb_aligned, f_aligned] = ...
        align2images_2points(v1,v2,im1,im2,...
            ext_vscale, ns_vscale,...
            extimage_xyscale,handles.nanosimsimage_xyscale,...
            log_flag1,log_flag2);
    
end
% add output to handles and update
handles.ext_aligned = ext_aligned;
handles.ext_aligned_xyscale = ext_aligned_xyscale;
%handles.rgb_aligned = rgb_aligned;
handles.f_aligned = f_aligned;
handles.align_type = align_type;
guidata(hObject, handles);

% --------------------------------------------------------------------
function export_aligned_external_Callback(hObject, eventdata, handles)
% hObject    handle to export_aligned_external (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% if strcmp(get(handles.show_alignment4,'Checked'),'on')
%     % alignment based on N>4 points
%     v1 = round(handles.extplist');
%     v2 = round(handles.nanosimsplist');
%     [im, rgb] = align2images(v1,v2,handles.extimage,handles.nanosimsimage);
% elseif strcmp(get(handles.show_alignment2,'Checked'),'on')
%     
% elseif strcmp(get(handles.align_interactively,'Checked'),'on')
% 
% end

if ~isfield(handles,'ext_aligned')
    warndlg('Please align images first.','LANS warning','modal');
else
    
    fprintf(1,'*** Select filename of the aligned external image.\n');
    fprintf(1,'* Choose MAT-format if you *do care* about the absolute values.\n');
    fprintf(1,'* Choose TIF-format if you *do not care* about the absolute values.\n');
    [FileName, bdir, exten] = uiputfile({'*.mat', 'I do care about absolute values (*.mat)';
        '*.tif', 'I do not care about the absolute values (*.tif)'},'Select output image filename',handles.imagedir);

    if length(FileName)+length(bdir)+length(exten)>3
        fn = [bdir FileName];
        global additional_settings;

        % save aligned external image
        if exten==1
            % in matlab format           
            ext.im = handles.ext_aligned;
            ext.xyscale = handles.ext_aligned_xyscale;
            ext.mag_factor_used = handles.mag_factor;
            save(fn, 'ext', '-v6');
        else
            % in TIF format
            % rescale it first to 0->255
            im1 = handles.ext_aligned;
            sc1 = find_image_scale(im1(im1>0),0,additional_settings.autoscale_quantiles,0,0);
            min1 = str2num(get(handles.min_ext,'String'));
            max1 = str2num(get(handles.max_ext,'String'));
            if isnumeric(min1), sc1(1)=min1; end
            if isnumeric(max1), sc1(2)=max1; end
            im1 = (im1-sc1(1))/diff(sc1);
            im1(im1<0)=0;
            im1(im1>1)=1;
            im1 = uint8(im1*255);
            imwrite(im1,fn);
        end
        fprintf(1,'Aligned external image saved as %s\n',fn);

        % save also the rgb overlay image
        
        %fn = [pathstr delimiter name '_rgb.tif'];
        %imwrite(handles.rgb_aligned,fn);
        %fprintf(1,'External and Nanosims overlay saved as %s\n',fn);

        % save also the figure with the results of the overlay as EPS or PNG
        % PNG is needed to support transparency
        if isvalid(handles.f_aligned)
            fext = figure(handles.f_aligned);
            [pathstr, name, exten] = fileparts(fn);
            if handles.align_type == 2
                fn = [pathstr delimiter name '.eps'];
                ff = [12/5 1];
                print_figure(fext,fn,additional_settings.print_factors(1)*ff);
                mepstopdf(fn,'epstopdf',1,1,0);
            else
                ff = 1;
                fn = [pathstr delimiter name '.png'];
                set(fext,'PaperPosition',[0.2500 2.5000 6 6]);
                print(fn,fext,'-dpng','-r300');
                fprintf(1,'Figure with the overlay exported as %s\n',fn);
            end
        else
            fprintf(1,'WARNING: Overlay figure not exported.\n')
            fprintf(1,'Keep the overlay figure open if you want to have it exported.\n');
        end
        
    end
end

    % save also the original external and nanosims images separately, with the points
%     global additional_settings;
%     f1=figure(120);
%     hold off;
%     im = handles.extimage;
%     if size(im,3)>1
%         image(im);
%     else        
%         %sc=quantile(double(im(:)),additional_settings.autoscale_quantiles);
%         sc = find_image_scale(double(im));
%         imagesc(im,sc);
%         colormap(gray);
%     end;
%     xl = get(gca,'xlim');
%     hold on;
%     plist = handles.extplist;
%     n=size(plist,1);
%     for ii=1:n
%         p1=plot(plist(ii,1),plist(ii,2),'wo');
%         p2=plot(plist(ii,1),plist(ii,2),'w.');    
%         tt=text(plist(ii,1)+diff(xl)/64,plist(ii,2),num2str(ii));
%         set(tt,'color',[1 1 1],'Fontsize',14,'FontWeight','bold');
%     end;
%     set(gca,'xticklabel',[],'yticklabel',[],'dataaspectratio',[1 1 1]);
%     fn = [pathstr delimiter name '_ext.eps'];
%     
%     print_figure(gcf,fn,additional_settings.print_factors(1));
%     %fprintf(1,'External image with alignment points exported as %s\n',fn);
% 
%     close(f1);
%     f1=figure(120);
%     hold off;
%     im = handles.nanosimsimage;
%     if size(im,3)>1
%         image(im);
%     else
%         %sc=quantile(double(im(:)),additional_settings.autoscale_quantiles);
%         sc = find_image_scale(double(im),0,additional_settings.autoscale_quantiles,0);
%         imagesc(im,sc);
%         colormap(gray);
%     end;
%     xl = get(gca,'xlim');
%     hold on;
%     plist = handles.nanosimsplist;
%     n=size(plist,1);
%     for ii=1:n
%         p1=plot(plist(ii,1),plist(ii,2),'wo');
%         p2=plot(plist(ii,1),plist(ii,2),'w.');    
%         tt=text(plist(ii,1)+diff(xl)/64,plist(ii,2),num2str(ii));
%         set(tt,'color',[1 1 1],'Fontsize',14,'FontWeight','bold');
%     end;
%     set(gca,'xticklabel',[],'yticklabel',[],'dataaspectratio',[1 1 1]);
%     fn = [pathstr delimiter name '_lans.eps'];
%     print_figure(gcf,fn,additional_settings.print_factors(1));
%     %fprintf(1,'Nanosims image with alignment points exported as %s\n',fn);
%     close(f1);
%    
%else
%    fprintf(1,'No valid file selected, nothing done.\n');
%end

a=1;

% --------------------------------------------------------------------
function action_Callback(hObject, eventdata, handles)
% hObject    handle to action (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function load_images_Callback(hObject, eventdata, handles)
% hObject    handle to load_images (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function load_external_image_Callback(hObject, eventdata, handles)
% hObject    handle to load_external_image (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

[FileName,newdir,newext] = uigetfile({'*.mat';'*.bmp';'*.png';'*.xyz';'*.tif';'*.*'}, ...
    'Select external image', handles.imagedir);
handles.imagedir = newdir;
handles.extimagefile = [newdir FileName];

if newext==4 % xyz file (AFM) was selected
    fprintf(1,'Reading xyz file.\n');
    %t=readtable(handles.extimagefile,'FileType','text');    
    t=importdata(handles.extimagefile,'\t',0);
    x=t(:,1); y=t(:,2); z=t(:,3);
    clear t;
    % reformat into an image
    xu=unique(x);
    yu=unique(y);
    % recalculate x and y to integer numbers
    x=round(x/max(x)*length(xu));
    y=round(y/max(y)*length(yu));
    im=accumarray([y x], z);
    x_size = length(xu);
    y_size = length(yu);
    zfac = 1e9;
    a=inputdlg({'Desired x-size (in pixels) of the external data',...
        'Desired y-size (in pixels) of the external data',...
        'Conversion factor for z-data'},...
        'Rescale external data',1,...
        {num2str(x_size), num2str(y_size), sprintf('%.1e',zfac)});
    if ~isempty(a)
        x_size = str2num(a{1});
        y_size = str2num(a{2});
        zfac = str2num(a{3});
    end
    % final resizing and z-rescaling
    mag_factor_used = x_size/length(xu);
    im = zfac*imresize(im, mag_factor_used, 'method','nearest');    
    fprintf(1,'Done.\nZ converted by a factor %.1e, image size rescaled by a factor %.1e.\n',...
        zfac, mag_factor_used');
    fprintf(1,'[min max] values = [%.3e %.3e]\n',min(im(:)),max(im(:)));
    % calculate also the xyscale of the image, based on the x's, and
    % convert it to microns
    xyscale = 1e6*(max(xu) - min(xu) + mean(diff(xu)));
elseif newext==1 % mat file (produced by LANS) selected
    a = load(handles.extimagefile);
    im =  a.IM;
    xyscale = a.xyscale;
    if ~isfield(a,'mag_factor_used')
        a.mag_factor_used = 1;
    end
    mag_factor_used = a.mag_factor_used;
    if isfield(a,'vscale')
        set(handles.min_ext,'String',num2str(a.vscale(1)));
        set(handles.max_ext,'String',num2str(a.vscale(2)));
    end    
else
    im=double(imread(handles.extimagefile));
    xyscale = size(im,2);
    mag_factor_used = 1;
end
% some external images can contain the fourth "color" (probably if they are
% in CMYK rather than RGB), so just ignore the 4th channel.
if size(im,3)>3
    im = im(:,:,1:3);
end
axes(handles.axes1);

if size(im,3)>1
    % rgb image loaded, rescale it such that max=1
    mim = max(im(:));
    if mim~=0
        im = im/mim;
    end
    image(im);
    % update the min/max fields
    set(handles.min_ext,'String', num2str(min(im(:))))
    set(handles.max_ext,'String', num2str(max(im(:))))
else
    %global additional_settings;
    %sc=quantile(double(im(:)),additional_settings.autoscale_quantiles);
    sc = find_image_scale(double(im));
    min1 = str2num(get(handles.min_ext,'String'));
    max1 = str2num(get(handles.max_ext,'String'));
    %if isnumeric(min1), sc(1)=min1; end
    %if isnumeric(max1), sc(2)=max1; end    
    imagesc(im,sc);    
    global additional_settings;
    colormap(get_colormap(additional_settings.colormap));
    % update the min/max fields
    set(handles.min_ext,'String', num2str(sc(1)))
    set(handles.max_ext,'String', num2str(sc(2)))
end
set(handles.checkbox1,'value',0);
% fill and remember output
handles.extimage=im;
handles.extimage_xyscale = xyscale;
handles.mag_factor_used = mag_factor_used;
global extimage_size newxLim1 newyLim1 
newxLim1 = xlim;
newyLim1 = ylim;
extimage_size = size(handles.extimage);
guidata(hObject, handles);

function log_transform_ext_image(hObject, eventdata, handles)
update_points_Callback(hObject, eventdata, handles);

% --------------------------------------------------------------------
function load_nanosims_image_Callback(hObject, eventdata, handles)
% hObject    handle to load_nanosims_image (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

global additional_settings;

[FileName,newdir,newext] = uigetfile({'*.mat';'*.tif';'*.*'}, 'Select nanoSIMS image', handles.imagedir);
handles.imagedir = newdir;
handles.nanosimsimagefile = [newdir FileName];

if newext == 1
    a=load(handles.nanosimsimagefile);
    im=a.IM;
    vscale = find_image_scale(im,0,additional_settings.autoscale_quantiles, 0);
    xyscale = size(im,2);
    if isfield(a,'vscale')
        vscale=a.vscale;
    end
    if isfield(a,'xyscale')
        xyscale=a.xyscale;
    end
else
    im=double(imread(handles.nanosimsimagefile));
    % rgb image loaded, rescale it such that max=1
    mim = max(im(:));
    if mim~=0
        im = im/mim;
    end
    % update the min/max fields
    set(handles.min_ns,'String', num2str(min(im(:))))
    set(handles.max_ns,'String', num2str(max(im(:))))
    vscale = find_image_scale(im,0,additional_settings.autoscale_quantiles, 0);
    xyscale = size(im,2);
end
axes(handles.axes2);
if size(im,3)>1
    image(im);
else
    sc=vscale;
    set(handles.min_ns,'String',num2str(vscale(1)));
    set(handles.max_ns,'String',num2str(vscale(2)));    
    imagesc(im,sc);
    colormap(get_colormap(additional_settings.colormap));
end
set(handles.checkbox2,'value',0);
% fill and remember output
handles.nanosimsimage=im;
handles.nanosimsimage_xyscale=xyscale;
global nanosimsimage_size newxLim2 newyLim2
newxLim2 = xlim;
newyLim2 = ylim;
nanosimsimage_size = size(handles.nanosimsimage);
guidata(hObject, handles);

% --------------------------------------------------------------------
function load_point_list_Callback(hObject, eventdata, handles)
% hObject    handle to load_point_list (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

[FileName,newdir,newext] = uigetfile( {'*.mat';'*.dpl'} , 'Select point-list file', handles.imagedir);

fn = [newdir FileName];
if newext>0

    if newext == 1
        a=load(fn);
        fprintf(1,'List of points loaded from %s\n',fn);
        plist = a.plist;

        handles.extplist = plist.extplist;
        handles.nanosimsplist = plist.nanosimsplist;
        if isfield(plist,'mag_factor')
            handles.mag_factor = plist.mag_factor;
            fprintf(1,'Points defined for nanoSIMS data magnified by a factor %d\n', plist.mag_factor);
        end
    end

    if newext == 2
        [a, b, c]=fileparts(fn);
        if ~isempty(findstr(b,'_ext'))
            opts = detectImportOptions(fn,'FileType','text');
            t1 = readtable(fn,opts);
            handles.extplist = table2array(t1);
            fprintf(1,'List of points for the external image loaded.\n');
            fprintf(1,'%f\t%f\n',handles.extplist');
        end
        if ~isempty(findstr(b,'_ns'))
            opts = detectImportOptions(fn,'FileType','text');
            t1 = readtable(fn,opts);
            handles.nanosimsplist = table2array(t1);
            fprintf(1,'List of points for the nanosims image loaded.\n');
            fprintf(1,'%f\t%f\n',handles.nanosimsplist');
        end        
    end

    guidata(hObject, handles);
    update_points_Callback(hObject, eventdata, handles);
    
end

% --------------------------------------------------------------------
function save_point_list_Callback(hObject, eventdata, handles)
% hObject    handle to save_point_list (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

[FileName,newdir,newext] = uiputfile( '*.mat', 'Select point-list file', handles.imagedir);

if newext~=0
    
    plist.imagedir = handles.imagedir;
    plist.extimagefile = handles.extimagefile;
    plist.nanosimsimagefile = handles.nanosimsimagefile;
    plist.extplist = handles.extplist;
    plist.nanosimsplist = handles.nanosimsplist;
    plist.mag_factor = handles.mag_factor;
    fn = [newdir FileName];
    
    save(fn,'plist','-v6');
    fprintf(1,'Point list saved in %s\n',fn);
    % save the points positions also as x-y data file, to make it easier to
    % see without matlab
    [a, b] = fileparts(fn);
    fn1 = [a filesep b '_ext.dpl'];
    a = plist.extplist;
    save(fn1,'a','-ascii');
    fprintf(1,'Point list for the external image also saved in %s\n',fn1);
    [a, b] = fileparts(fn);
    fn2 = [a filesep b '_ns.dpl'];
    a = plist.nanosimsplist;
    save(fn2,'a','-ascii');
    fprintf(1,'Point list for the nanosims image also saved in %s\n',fn2);    
    
end
        

function zoom_Callback(hObject,eventdata,handles)

if strcmp(get(hObject,'checked'),'off')
    h = zoom;
    fprintf(1,'**************************************************************\n')
    fprintf(1,'Select the zoomed-in region in the image, THEN\n');
    fprintf(1,'Select Zoom -> "Zoom DISABLE" to quit the zoom-in mode, THEN\n');
    fprintf(1,'Continue with other actions.\n');
    fprintf(1,'**************************************************************\n')
    %if hObject == handles.zoom_external
        h.ActionPreCallback = @myprecallback;
        h.ActionPostCallback = @newxylim; %@mypostcallback;
        newlabel = 'Zoom DISABLE';
%     elseif hObject == handles.zoom_nanosims
%         h.ActionPreCallback = @myprecallback2;
%         h.ActionPostCallback = @mypostcallback2;
%         newlabel = 'Zoom nanosims DISABLE';
%     end
    h.Enable = 'on';   
    %zoom on;
    %set(hObject,'checked','on');    
    set(hObject,'label',newlabel);
    set(handles.figure1,'Color',[1 1 1]*0.6);
    %set(handles.text1,'BackgroundColor',[1 1 1]*0.6);
    set(hObject,'Checked','on');
else
    %h.Enable = 'off';
    zoom off;
%     if hObject == handles.zoom_external
%         newlabel = 'Zoom external ENABLE';
        global newxLim1 newyLim1;
        handles.axes1.XLim = newxLim1;
        handles.axes1.YLim = newyLim1;
%     elseif hObject == handles.zoom_nanosims
%         newlabel = 'Zoom nanosims ENABLE';
        global newxLim2 newyLim2;
        handles.axes2.XLim = newxLim2;
        handles.axes2.YLim = newyLim2;
%     end
    set(hObject,'checked','off', 'label', 'Zoom ENABLE');
    %set(hObject,'label','Zoom ENABLE');
    set(handles.figure1,'Color',[0.83 0.82 0.78]*1);
    %set(handles.text1,'BackgroundColor',[0.83 0.82 0.78]*1);    
end

function myprecallback(obj,evd)
% global newxLim1 newyLim1;
% newxLim1 = get(evd.Axes,'XLim');
% newyLim1 = get(evd.Axes,'YLim');
% fprintf(1,'PreCall: X-Limits and Y-Limits are [%.2f %.2f] [%.2f %.2f]\n',newxLim1,newyLim1);

function myprecallback2(obj,evd)
% global newxLim2 newyLim2;
% newxLim2 = get(evd.Axes,'XLim');
% newyLim2 = get(evd.Axes,'YLim');
% fprintf(1,'PreCall: X-Limits and Y-Limits are [%.2f %.2f] [%.2f %.2f]\n',newxLim2,newyLim2);

function mypostcallback(obj,evd)
%global newxLim1 newyLim1;
%ax=gca;

%[newxLim, newyLim] = newxylim(evd,newxLim1,newyLim1);
newxLim1 = newxLim;
newyLim1 = newyLim;

function mypostcallback2(obj,evd)
global newxLim2 newyLim2;
[newxLim, newyLim] = newxylim(evd,newxLim2,newyLim2);
newxLim2 = newxLim;
newyLim2 = newyLim;

%function [newxLim, newyLim] = newxylim(obj,evd) %,newxLim,newyLim)
function newxylim(obj,evd) %,newxLim,newyLim)
global nanosimsimage_size;
xl = round(get(evd.Axes,'XLim'));
yl = round(get(evd.Axes,'YLim'));
% make sure that an area is selected with the same aspect ratio as the
% original nanosims image
dx = diff(xl);
dy = diff(yl);
rext = nanosimsimage_size(1)/nanosimsimage_size(2);
rcur = dy/dx;
if rext~=rcur
    fprintf(1,'Axes limits adjusted to match the aspect ratio of the original nanosims image.\n');
end
dd = min([dx dy/rext]);
if xl(1)==1, xl(1)=0.5; end
if yl(1)==1, yl(1)=0.5; end
xmax = xl(1) + dd;
ymax = yl(1) + dd*rext;
newxLim = [xl(1) round(xmax)];
newyLim = [yl(1) round(ymax)];
set(evd.Axes,'XLim',newxLim)
set(evd.Axes,'YLim',newyLim)
fprintf(1,'New X-Limits and Y-Limits are [%.1f %.1f] [%.1f %.1f]\n',newxLim,newyLim);
global newxLim1 newyLim1 newxLim2 newyLim2 align_axes1 align_axes2
if evd.Axes == align_axes1
    newxLim1 = newxLim;
    newyLim1 = newyLim;
elseif evd.Axes == align_axes2
    newxLim2 = newxLim;
    newyLim2 = newyLim;
end
    


% function zoom_Callback2(hObject,eventdata,handles)
% 
% fprintf(1,'Zooming on\n');
% a=0;
% 
% if hObject == handles.zoom_external
%     axes(handles.axes1);
%     if strcmp(get(handles.zoom_external,'Checked'),'off')
%         zoom on
%         set(handles.zoom_external,'Checked','on');
%     else
%         zoom off
%         set(handles.zoom_external,'Checked','off');
%     end
% end
% 
% if hObject == handles.zoom_nanosims
%     axes(handles.axes2);
%     if strcmp(get(handles.zoom_nanosims,'Checked'),'off')
%         zoom on
%         set(handles.zoom_nanosims,'Checked','on');
%     else
%         zoom off
%         set(handles.zoom_nanosims,'Checked','off');
%     end
% end
        
function move_view_Callback(hObject,eventdata,handles)
fprintf(1,'*** Interactive centering of view field of view\n');
fprintf(1,'Left-click on the image to center the view to the clicked point.\n');
fprintf(1,'Right-click, Esc or Enter to stop.\n');

global newxLim1 newyLim1 newxLim2 newyLim2;

set(gcf, 'pointer', 'cross');

m=1; p=[];
while m~=3 & m~=13 & m~=27
        
    [x y m ax] = my_ginput(handles.figure1);
    x=round(x);
    y=round(y);
    if isempty(m)
        m=3;
    end

    if m==1
        if ax == handles.axes1
            dx = diff(newxLim1);
            dy = diff(newyLim1);
            newxLim1 = x+dx/2*[-1 1];
            newyLim1 = y+dx/2*[-1 1];
            set(ax,'xlim',newxLim1,'ylim',newyLim1);
        elseif ax == handles.axes2
            dx = diff(newxLim2);
            dy = diff(newyLim2);
            newxLim2 = x+dx/2*[-1 1];
            newyLim2 = y+dx/2*[-1 1];
            set(ax,'xlim',newxLim2,'ylim',newyLim2);
        end
    end
    
end

set(gcf, 'pointer', 'arrow');














function zoomout_Callback(hObject,eventdata,handles)
%fprintf(1,'Click on the image to zoom out\n');
x1 = [ 0.5 size(handles.extimage,2)+0.5];
y1 = [ 0.5 size(handles.extimage,1)+0.5];
x2 = [ 0.5 size(handles.nanosimsimage,2)+0.5];
y2 = [ 0.5 size(handles.nanosimsimage,1)+0.5];
handles.axes1.XLim = x1;
handles.axes1.YLim = y1;
handles.axes2.XLim = x2;
handles.axes2.YLim = y2;
global newxLim1 newyLim1 newxLim2 newyLim2;
newxLim1 = x1;
newyLim1 = y1;
newxLim2 = x2;
newyLim2 = y2;

% --------------------------------------------------------------------
function update_points_Callback(hObject, eventdata, handles)
% hObject    handle to update_points (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

global additional_settings;

if isfield(handles,'extimage')
    im = handles.extimage;
    log_flag = get(handles.checkbox1,'value');
    ax = handles.axes1;
    x1 = get(ax,'xlim');
    y1 = get(ax,'ylim');    
    if ~isempty(im)
        % redisplay the external image
        axes(ax); hold off
        sc = find_image_scale(im,0,additional_settings.autoscale_quantiles, log_flag,0);
        min1 = str2num(get(handles.min_ext,'String'));
        max1 = str2num(get(handles.max_ext,'String'));
        if isnumeric(min1), sc(1)=min1; end
        if isnumeric(max1), sc(2)=max1; end
        % log-transform, if needed
        if log_flag
            im2 = log10(im);
            sc = log10(sc);
            if isinf(sc(1)), sc(1)=sc(2)-3; end
        else
            im2 = im;
        end
        % display image, two ways depending on whether it's an rgb or
        % a grayscale image
        if size(im,3)>1
            im2 = (im2-sc(1))/diff(sc);
            im2(im2<0) = 0;
            im2(im2>1) = 1;
            image(im2);
        else
            if contains(get(hObject,'Tag'),'min_') || contains(get(hObject,'Tag'),'max_')    
                fprintf(1,'Ext image scale set to [%.2e, %.2e]\n', sc); 
            end
            imagesc(im2, sc);
            colormap(get_colormap(additional_settings.colormap));
        end

        % add the points
        hold on;
        if isfield(handles,'extplist')
            plist = handles.extplist;
            n=size(plist,1);
            %xl=get(gca,'xlim');
            fprintf(1,'List of points defined for the external image\n');
            for ii=1:n
                plot(plist(ii,1),plist(ii,2),[handles.points_color_symbol 'x'],'markerfacecolor',[1 1 1],'markersize',12,'linewidth',2);
                tt=text(plist(ii,1)+diff(x1)/64,plist(ii,2),num2str(ii));
                set(tt,'color',handles.points_font_color);
                fprintf(1,'%d: %d %d\n',ii,round(plist(ii,:)));
            end
        end
    else
        warndlg('External image empty. Please load it first.','Warning','modal');
    end
    set(ax,'xlim',x1,'ylim',y1);
end

if isfield(handles,'nanosimsimage')
    im=handles.nanosimsimage;
    log_flag = get(handles.checkbox2,'value');
    ax = handles.axes2;
    x1 = get(ax,'xlim');
    y1 = get(ax,'ylim');    
    if ~isempty(im)
        axes(ax); hold off;
        sc = find_image_scale(im,0,additional_settings.autoscale_quantiles, log_flag,0);
        min1 = str2num(get(handles.min_ns,'String'));
        max1 = str2num(get(handles.max_ns,'String'));
        if isnumeric(min1), sc(1)=min1; end
        if isnumeric(max1), sc(2)=max1; end
        if log_flag
            im2 = log10(im);
            sc = log10(sc);
            if isinf(sc(1)), sc(1)=sc(2)-3; end
        else
            im2 = im;
        end
        if size(im,3)>1
            im2 = (im2-sc(1))/diff(sc);
            im2(im2<0) = 0;
            im2(im2>1) = 1;
            image(im2);
        else
            if contains(get(hObject,'Tag'),'min_') || contains(get(hObject,'Tag'),'max_')
                fprintf(1,'Nanosims image scale set to [%.2e, %.2e]\n', sc); 
            end
            imagesc(im2, sc);
            colormap(get_colormap(additional_settings.colormap));
        end
        hold on;
        if isfield(handles,'nanosimsplist')
            plist = handles.nanosimsplist;
            n=size(plist,1);
            %xl=get(gca,'xlim');
            fprintf(1,'List of points defined for the nanosims image\n');
            for ii=1:n
                plot(plist(ii,1),plist(ii,2),[handles.points_color_symbol '+'],'markerfacecolor',[1 1 1],'markersize',12,'linewidth',2);
                tt=text(plist(ii,1)+diff(x1)/64,plist(ii,2),num2str(ii));
                set(tt,'color',handles.points_font_color);
                fprintf(1,'%d: %d %d\n',ii,round(plist(ii,:)));
            end
        end
    else
        warndlg('Nanosims image empty. Please load it first.','Warning','modal');    
    end
    set(ax,'xlim',x1,'ylim',y1);
end

function change_points_color_Callback(hObject, eventdata, handles)

x=inputdlg({'Enter color for the defined points (e.g., k,w,r,g,b,m,c)',
    'Enter color for the points ID numbers'},...
        'LANS input',1,...
        {handles.points_color_symbol, handles.points_font_color});
if ~isempty(x)
    handles.points_color_symbol = x{1};
    handles.points_font_color = x{2};
    guidata(hObject, handles);
    update_points_Callback(hObject, eventdata, handles);
end
